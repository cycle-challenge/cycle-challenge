// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'place_sort_option.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$PlaceSortOption {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() nearest,
    required TResult Function() highestRated,
    required TResult Function() mostReviewed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? nearest,
    TResult? Function()? highestRated,
    TResult? Function()? mostReviewed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nearest,
    TResult Function()? highestRated,
    TResult Function()? mostReviewed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Nearest value) nearest,
    required TResult Function(_HighestRated value) highestRated,
    required TResult Function(_MostReviewed value) mostReviewed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Nearest value)? nearest,
    TResult? Function(_HighestRated value)? highestRated,
    TResult? Function(_MostReviewed value)? mostReviewed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Nearest value)? nearest,
    TResult Function(_HighestRated value)? highestRated,
    TResult Function(_MostReviewed value)? mostReviewed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PlaceSortOptionCopyWith<$Res> {
  factory $PlaceSortOptionCopyWith(
          PlaceSortOption value, $Res Function(PlaceSortOption) then) =
      _$PlaceSortOptionCopyWithImpl<$Res, PlaceSortOption>;
}

/// @nodoc
class _$PlaceSortOptionCopyWithImpl<$Res, $Val extends PlaceSortOption>
    implements $PlaceSortOptionCopyWith<$Res> {
  _$PlaceSortOptionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$NearestImplCopyWith<$Res> {
  factory _$$NearestImplCopyWith(
          _$NearestImpl value, $Res Function(_$NearestImpl) then) =
      __$$NearestImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NearestImplCopyWithImpl<$Res>
    extends _$PlaceSortOptionCopyWithImpl<$Res, _$NearestImpl>
    implements _$$NearestImplCopyWith<$Res> {
  __$$NearestImplCopyWithImpl(
      _$NearestImpl _value, $Res Function(_$NearestImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NearestImpl implements _Nearest {
  const _$NearestImpl();

  @override
  String toString() {
    return 'PlaceSortOption.nearest()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NearestImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() nearest,
    required TResult Function() highestRated,
    required TResult Function() mostReviewed,
  }) {
    return nearest();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? nearest,
    TResult? Function()? highestRated,
    TResult? Function()? mostReviewed,
  }) {
    return nearest?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nearest,
    TResult Function()? highestRated,
    TResult Function()? mostReviewed,
    required TResult orElse(),
  }) {
    if (nearest != null) {
      return nearest();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Nearest value) nearest,
    required TResult Function(_HighestRated value) highestRated,
    required TResult Function(_MostReviewed value) mostReviewed,
  }) {
    return nearest(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Nearest value)? nearest,
    TResult? Function(_HighestRated value)? highestRated,
    TResult? Function(_MostReviewed value)? mostReviewed,
  }) {
    return nearest?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Nearest value)? nearest,
    TResult Function(_HighestRated value)? highestRated,
    TResult Function(_MostReviewed value)? mostReviewed,
    required TResult orElse(),
  }) {
    if (nearest != null) {
      return nearest(this);
    }
    return orElse();
  }
}

abstract class _Nearest implements PlaceSortOption {
  const factory _Nearest() = _$NearestImpl;
}

/// @nodoc
abstract class _$$HighestRatedImplCopyWith<$Res> {
  factory _$$HighestRatedImplCopyWith(
          _$HighestRatedImpl value, $Res Function(_$HighestRatedImpl) then) =
      __$$HighestRatedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$HighestRatedImplCopyWithImpl<$Res>
    extends _$PlaceSortOptionCopyWithImpl<$Res, _$HighestRatedImpl>
    implements _$$HighestRatedImplCopyWith<$Res> {
  __$$HighestRatedImplCopyWithImpl(
      _$HighestRatedImpl _value, $Res Function(_$HighestRatedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$HighestRatedImpl implements _HighestRated {
  const _$HighestRatedImpl();

  @override
  String toString() {
    return 'PlaceSortOption.highestRated()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$HighestRatedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() nearest,
    required TResult Function() highestRated,
    required TResult Function() mostReviewed,
  }) {
    return highestRated();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? nearest,
    TResult? Function()? highestRated,
    TResult? Function()? mostReviewed,
  }) {
    return highestRated?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nearest,
    TResult Function()? highestRated,
    TResult Function()? mostReviewed,
    required TResult orElse(),
  }) {
    if (highestRated != null) {
      return highestRated();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Nearest value) nearest,
    required TResult Function(_HighestRated value) highestRated,
    required TResult Function(_MostReviewed value) mostReviewed,
  }) {
    return highestRated(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Nearest value)? nearest,
    TResult? Function(_HighestRated value)? highestRated,
    TResult? Function(_MostReviewed value)? mostReviewed,
  }) {
    return highestRated?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Nearest value)? nearest,
    TResult Function(_HighestRated value)? highestRated,
    TResult Function(_MostReviewed value)? mostReviewed,
    required TResult orElse(),
  }) {
    if (highestRated != null) {
      return highestRated(this);
    }
    return orElse();
  }
}

abstract class _HighestRated implements PlaceSortOption {
  const factory _HighestRated() = _$HighestRatedImpl;
}

/// @nodoc
abstract class _$$MostReviewedImplCopyWith<$Res> {
  factory _$$MostReviewedImplCopyWith(
          _$MostReviewedImpl value, $Res Function(_$MostReviewedImpl) then) =
      __$$MostReviewedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MostReviewedImplCopyWithImpl<$Res>
    extends _$PlaceSortOptionCopyWithImpl<$Res, _$MostReviewedImpl>
    implements _$$MostReviewedImplCopyWith<$Res> {
  __$$MostReviewedImplCopyWithImpl(
      _$MostReviewedImpl _value, $Res Function(_$MostReviewedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MostReviewedImpl implements _MostReviewed {
  const _$MostReviewedImpl();

  @override
  String toString() {
    return 'PlaceSortOption.mostReviewed()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$MostReviewedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() nearest,
    required TResult Function() highestRated,
    required TResult Function() mostReviewed,
  }) {
    return mostReviewed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? nearest,
    TResult? Function()? highestRated,
    TResult? Function()? mostReviewed,
  }) {
    return mostReviewed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nearest,
    TResult Function()? highestRated,
    TResult Function()? mostReviewed,
    required TResult orElse(),
  }) {
    if (mostReviewed != null) {
      return mostReviewed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Nearest value) nearest,
    required TResult Function(_HighestRated value) highestRated,
    required TResult Function(_MostReviewed value) mostReviewed,
  }) {
    return mostReviewed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Nearest value)? nearest,
    TResult? Function(_HighestRated value)? highestRated,
    TResult? Function(_MostReviewed value)? mostReviewed,
  }) {
    return mostReviewed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Nearest value)? nearest,
    TResult Function(_HighestRated value)? highestRated,
    TResult Function(_MostReviewed value)? mostReviewed,
    required TResult orElse(),
  }) {
    if (mostReviewed != null) {
      return mostReviewed(this);
    }
    return orElse();
  }
}

abstract class _MostReviewed implements PlaceSortOption {
  const factory _MostReviewed() = _$MostReviewedImpl;
}
